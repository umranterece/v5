<template>
  <div class="video-grid-container">
    <!-- Layout Controls -->
    <LayoutControls
      v-if="showLayoutControls"
      :layout-manager="layoutManager"
      :current-mode="currentLayoutMode"
      :user-count="allUsers.length"
      :performance="currentPerformance"
      @view-mode-changed="handleViewModeChanged"
      @auto-layout-toggled="handleAutoLayoutToggled"
      @performance-mode-toggled="handlePerformanceModeToggled"
    />
    
    <!-- Video Grid -->
    <div 
      ref="videoGridRef"
      class="video-grid"
      :class="`layout-${currentLayoutMode}`"
      :style="gridStyles"
    >
      <!-- Layout Engine ile render edilen video öğeleri -->
      <VideoItem 
        v-for="gridItem in currentLayout?.grid || []"
        :key="`${gridItem.user.uid}-${gridItem.user.isScreenShare ? 'screen' : 'video'}`"
        :user="gridItem.user"
        :has-video="getUserHasVideo(gridItem.user)"
        :video-ref="el => setVideoRef(el, gridItem.user.uid)"
        :track="getUserTrack(gridItem.user)"
        :is-local="gridItem.user.isLocal"
        :is-screen-share="gridItem.user.isScreenShare"
        :logUI="logUI"
        :style="getVideoItemStyles(gridItem)"
        :class="getVideoItemClasses(gridItem)"
      />
    </div>
    
    <!-- Layout Info Debug -->
    <div v-if="showDebugInfo" class="layout-debug-info">
      <div class="debug-item">
        <span class="debug-label">Mode:</span>
        <span class="debug-value">{{ currentLayoutMode }}</span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Users:</span>
        <span class="debug-value">{{ allUsers.length }}</span>
      </div>
      <div class="debug-item">
        <span class="debug-label">Grid Items:</span>
        <span class="debug-value">{{ currentLayout?.grid?.length || 0 }}</span>
      </div>
      <div v-if="currentPerformance" class="debug-item">
        <span class="debug-label">Render Time:</span>
        <span class="debug-value">{{ currentPerformance.renderTime.toFixed(2) }}ms</span>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed, ref, onMounted, onBeforeUnmount, watch, nextTick } from 'vue'
import VideoItem from './VideoItem.vue'
import { LayoutManager, ViewMode, Dimensions } from '../layout/index.js'

// Props
const props = defineProps({
  allUsers: { type: Array, default: () => [] },
  localTracks: { type: Object, default: () => ({}) },
  localVideoRef: { type: Object, default: null },
  localScreenRef: { type: Object, default: null },
  logUI: { type: Function, default: () => {} },
  showLayoutControls: { type: Boolean, default: true },
  showDebugInfo: { type: Boolean, default: false }
})

// Emits
const emit = defineEmits(['set-video-ref', 'set-local-video-ref', 'set-local-screen-ref'])

// Layout Engine State
const layoutManager = ref(null)
const currentLayout = ref(null)
const currentLayoutMode = ref(ViewMode.GRID)
const currentPerformance = ref(null)
const videoGridRef = ref(null)

// Layout Calculation
const calculateLayout = () => {
  if (!layoutManager.value || !videoGridRef.value) return
  
  // Container dimensions
  const container = new Dimensions(
    videoGridRef.value.offsetWidth,
    videoGridRef.value.offsetHeight
  )
  
  // Users with priority
  const users = props.allUsers.map(user => ({
    ...user,
    priority: user.isLocal ? 10 : (user.isScreenShare ? 8 : 5),
    isActive: user.isLocal || user.isScreenShare
  }))
  
  // Calculate layout
  const result = layoutManager.value.calculateAndApplyLayout(users, container, currentLayoutMode.value)
  
  if (result?.success) {
    props.logUI('Layout hesaplandı', {
      mode: currentLayoutMode.value,
      users: users.length,
      gridItems: result.layout?.grid?.length || 0
    })
  }
}

// Layout Engine Setup
const setupLayoutEngine = () => {
  layoutManager.value = new LayoutManager({
    maxColumns: 4,
    maxRows: 4,
    spacing: 8,
    autoSwitch: true,
    performanceMode: false
  })
  
  // Layout manager event listeners
  layoutManager.value.addListener('layout-changed', (data) => {
    currentLayout.value = data.layout
    currentLayoutMode.value = data.mode
    currentPerformance.value = data.performance
    
    props.logUI('Layout değişti', {
      mode: data.mode,
      gridItems: data.layout?.grid?.length || 0,
      performance: data.performance
    })
  })
  
  layoutManager.value.addListener('performance-warning', (warning) => {
    props.logUI('Layout performance uyarısı', warning)
  })
  
  // Initial layout calculation
  calculateLayout()
}

// Layout Calculation
const calculateLayout = () => {
  if (!layoutManager.value || !videoGridRef.value) return
  
  // Container dimensions
  const container = new Dimensions(
    videoGridRef.value.offsetWidth,
    videoGridRef.value.offsetHeight
  )
  
  // Users with priority
  const users = props.allUsers.map(user => ({
    ...user,
    priority: user.isLocal ? 10 : (user.isScreenShare ? 8 : 5),
    isActive: user.isLocal || user.isScreenShare
  }))
  
  // Calculate layout
  const result = layoutManager.value.calculateAndApplyLayout(users, container, currentLayoutMode.value)
  
  if (result?.success) {
    props.logUI('Layout hesaplandı', {
      mode: currentLayoutMode.value,
      users: users.length,
      gridItems: result.layout?.grid?.length || 0
    })
  }
}

// Computed
const gridStyles = computed(() => {
  if (!currentLayout.value) return {}
  
  return {
    width: `${currentLayout.value.dimensions?.width || '100%'}`,
    height: `${currentLayout.value.dimensions?.height || '100%'}`
  }
})

// Helper Functions
const getUserHasVideo = (user) => {
  const hasVideoTrack = !!user.hasVideo
  const notVideoOff = !user.isVideoOff
  const userExists = !!user
  
  props.logUI('Kullanıcı video durumu hesaplanıyor', {
    uid: user.uid,
    hasVideoTrack,
    notVideoOff,
    userExists,
    user
  })
  
  return hasVideoTrack && notVideoOff && userExists
}

const getUserTrack = (user) => {
  if (user.isLocal) {
    if (user.isScreenShare) {
      return props.localTracks.screen?.video
    } else {
      return props.localTracks.video?.video
    }
  }
  return user.track
}

const getVideoItemStyles = (gridItem) => {
  if (!gridItem.position) return {}
  
  return {
    position: 'absolute',
    left: `${gridItem.position.x}px`,
    top: `${gridItem.position.y}px`,
    width: `${gridItem.position.width}px`,
    height: `${gridItem.position.height}px`
  }
}

const getVideoItemClasses = (gridItem) => {
  return {
    'grid-item': true,
    'local': gridItem.user.isLocal,
    'screen-share': gridItem.user.isScreenShare,
    'active': gridItem.isActive,
    'priority-high': gridItem.priority >= 8
  }
}

const setLocalVideoRef = (el) => {
  props.logUI('Yerel video referansı ayarlanıyor', { element: !!el, hasRefProp: !!props.localVideoRef })
  if (props.localVideoRef && typeof props.localVideoRef === 'object' && 'value' in props.localVideoRef) {
    props.localVideoRef.value = el
    props.logUI('Yerel video referansı başarıyla ayarlandı')
  } else {
    props.logUI('Yerel video referans prop\'u geçerli bir ref objesi değil')
  }
  emit('set-local-video-ref', el)
}

const setLocalScreenRef = (el) => {
  props.logUI('Yerel ekran paylaşımı referansı ayarlanıyor', { 
    element: !!el, 
    hasRefProp: !!props.localScreenRef,
    elementType: el?.constructor?.name,
    elementId: el?.id,
    elementClass: el?.className
  })
  
  if (props.localScreenRef && typeof props.localScreenRef === 'object' && 'value' in props.localScreenRef) {
    props.localScreenRef.value = el
    props.logUI('Yerel ekran paylaşımı referansı başarıyla ayarlandı', {
      newRef: !!el,
      refType: el?.constructor?.name
    })
  } else {
    props.logUI('Yerel ekran paylaşımı referans prop\'u geçerli bir ref objesi değil', {
      hasRefProp: !!props.localScreenRef,
      refType: typeof props.localScreenRef
    })
  }
  emit('set-local-screen-ref', el)
}

const setVideoRef = (el, uid) => {
  emit('set-video-ref', el, uid)
}

// Layout Event Handlers
const handleViewModeChanged = (mode) => {
  currentLayoutMode.value = mode
  calculateLayout()
  
  props.logUI('View mode değişti', { mode })
}

const handleAutoLayoutToggled = (enabled) => {
  if (layoutManager.value) {
    layoutManager.value.options.autoSwitch = enabled
  }
  
  props.logUI('Auto-layout toggled', { enabled })
}

const handlePerformanceModeToggled = (enabled) => {
  if (layoutManager.value) {
    layoutManager.value.options.performanceMode = enabled
  }
  
  props.logUI('Performance mode toggled', { enabled })
}

// Lifecycle
onMounted(() => {
  nextTick(() => {
    setupLayoutEngine()
  })
})

onBeforeUnmount(() => {
  if (layoutManager.value) {
    layoutManager.value.destroy()
  }
})

// Watchers
watch(() => props.allUsers, () => {
  if (layoutManager.value) {
    calculateLayout()
  }
}, { deep: true })

watch(() => props.localTracks, () => {
  if (layoutManager.value) {
    calculateLayout()
  }
}, { deep: true })
</script>

<style scoped>
.video-grid-container {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

/* Layout Controls */
.layout-controls {
  position: absolute;
  top: 1rem;
  right: 1rem;
  z-index: 100;
  min-width: 200px;
}

/* Video Grid */
.video-grid {
  position: relative;
  width: 100%;
  height: 100%;
  min-height: 400px;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 0.75rem;
  overflow: hidden;
}

/* Layout Mode Specific Styles */
.video-grid.layout-grid {
  /* Grid layout styles */
}

.video-grid.layout-spotlight {
  /* Spotlight layout styles */
}

.video-grid.layout-gallery {
  /* Gallery layout styles */
}

.video-grid.layout-presentation {
  /* Presentation layout styles */
}

.video-grid.layout-mobile {
  /* Mobile layout styles */
}

/* Grid Items */
.grid-item {
  position: absolute;
  transition: all 0.3s ease;
  border-radius: 0.5rem;
  overflow: hidden;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.grid-item.local {
  border: 2px solid rgba(102, 126, 234, 0.5);
}

.grid-item.screen-share {
  border: 2px solid rgba(255, 193, 7, 0.5);
}

.grid-item.active {
  box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
}

.grid-item.priority-high {
  z-index: 10;
}

/* Layout Debug Info */
.layout-debug-info {
  position: absolute;
  bottom: 1rem;
  left: 1rem;
  background: rgba(0, 0, 0, 0.8);
  color: #ffffff;
  padding: 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  z-index: 50;
}

.debug-item {
  display: flex;
  justify-content: space-between;
  gap: 1rem;
  margin-bottom: 0.5rem;
}

.debug-item:last-child {
  margin-bottom: 0;
}

.debug-label {
  color: #9ca3af;
  font-weight: 500;
}

.debug-value {
  color: #e0e0e0;
  font-weight: 600;
}

/* Responsive Design */
@media (max-width: 768px) {
  .video-grid-container {
    gap: 0.5rem;
  }
  
  .layout-controls {
    position: relative;
    top: auto;
    right: auto;
    margin-bottom: 1rem;
  }
  
  .layout-debug-info {
    position: relative;
    bottom: auto;
    left: auto;
    margin-top: 1rem;
  }
  
  .video-grid {
    min-height: 300px;
  }
}

@media (max-width: 480px) {
  .layout-controls {
    min-width: auto;
    width: 100%;
  }
  
  .video-grid {
    min-height: 250px;
  }
}
</style> 